
package org.kie.kogito.addons.quarkus.knative.eventing.deployment;

import java.util.List;
import java.util.Optional;
import java.util.Set;

import io.quarkus.deployment.IsTest;
import io.quarkus.deployment.annotations.BuildProducer;
import io.quarkus.deployment.annotations.BuildStep;
import io.quarkus.kubernetes.deployment.SelectedKubernetesDeploymentTargetBuildItem;
import io.quarkus.kubernetes.spi.KubernetesResourceMetadataBuildItem;
import org.kie.kogito.codegen.process.events.ProcessCloudEventMeta;
import org.kie.kogito.codegen.process.events.ProcessCloudEventMetaBuilder;
import org.kie.kogito.quarkus.processes.deployment.KogitoProcessContainerGeneratorBuildItem;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Processor to generate cloud event metadata from BPMN/SW models
 */
public class KogitoProcessKnativeEventingProcessor {

    private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessKnativeEventingProcessor.class);
    private final ProcessCloudEventMetaBuilder cloudEventMetaBuilder;

    public KogitoProcessKnativeEventingProcessor() {
        this.cloudEventMetaBuilder = new ProcessCloudEventMetaBuilder();
    }

    // used in unit tests, don't expose
    KogitoProcessKnativeEventingProcessor(ProcessCloudEventMetaBuilder cloudEventMetaBuilder) {
        this.cloudEventMetaBuilder = cloudEventMetaBuilder;
    }

    /**
     * Builds the metadata required to create the Kogito Knative resources.
     * <p>
     * It only runs if the current build is not a test environment.
     * This conditional was borrowed from the original `KubernetesProcessor` build processor.
     *
     * @param processContainerBuildItem Build item generated by the kogito-processes-extension with the process context for the generated BPMN/SW files
     * @param selectedDeployment        Build item generated by the quarkus-kubernetes add-on when `quarkus.kubernetes.deploy.target` property is defined
     * @param kubernetesMetaBuildItems  Build items generated by the quarkus-kubernetes add-on when there's a target deployment resource
     * @param metadataProducer          outcome of this build step, it contains the information about cloudevents that should be used by later steps to generate Kogito Knative files
     */
    @BuildStep(onlyIfNot = IsTest.class)
    void buildMetadata(KogitoProcessContainerGeneratorBuildItem processContainerBuildItem,
                       SelectedKubernetesDeploymentTargetBuildItem selectedDeployment,
                       List<KubernetesResourceMetadataBuildItem> kubernetesMetaBuildItems,
                       BuildProducer<KogitoKnativeResourcesMetadataBuildItem> metadataProducer) {
        final Set<ProcessCloudEventMeta> cloudEvents = this.cloudEventMetaBuilder.build(processContainerBuildItem.getProcessContainerGenerators());
        if (cloudEvents != null && !cloudEvents.isEmpty()) {
            Optional<KogitoServiceDeploymentTarget> target = Optional.empty();
            if (kubernetesMetaBuildItems != null && !kubernetesMetaBuildItems.isEmpty()) {
                target = kubernetesMetaBuildItems.stream()
                        .filter(r -> selectedDeployment == null || selectedDeployment.getEntry().getKind().equals(r.getKind()) && selectedDeployment.getEntry().getName().equals(r.getTarget()))
                        .map(r -> new KogitoServiceDeploymentTarget(r.getGroup(), r.getVersion(), r.getKind(), r.getName()))
                        .findFirst();
            }

            if (target.isEmpty()) {
                LOGGER.warn("Impossible to get the Kubernetes deployment target for this Kogito service. Skipping generation.");
            } else {
                metadataProducer.produce(new KogitoKnativeResourcesMetadataBuildItem(cloudEvents, target.get()));
            }
        }
    }
}
